# Классы
`global` - переменная привязана к глобальной обл-ти видимости
`nonlocal` - связь с переменной обл-ти видимости выше
*instantiation* - создание объекта класса
`ClassName.__doc__` - возвращает докстринг
`object.__class__` - класс объекта (его тип)
`isinstance(obg, class)` - проверка типа экземпляра
`issubclass(sub_class, class)` - проверка наследования классов

#### Наследование
`class DerivedClassName(BaseClassName)`
У производного класса - свои методы + методы базового класса.
Возможна перегрузка ф-ций.
`BaseClassName.methodname(self, arguments)` - так можно обращаться к методам базового класса.
Поиск имени в производном классе - сначала в нём, потом в родителе, потом в родителе родителя, если есть, и т.д.
`class DerivedClassName(Base1, Base2, Base3)` - множественное наследование
*Путь поиска атрибутов:*
В простом смысле: «сперва вглубь», затем «слева направо».
В более сложном, когда допустимы ромбовидные конструкции: всё сложнее.

Приватных переменных экземпляра нет!, но есть *соглашения*:
`_spam` -  любой идентификатор, считаемый непубличной частью API.
`__spam` (не менее двух ведущих подчеркиваний, не более одного последнего подчеркивания) -> `_classname__spam` - механизм искажения (mangling) имён
где `classname` - имя класса без ведущих подчёркиваний.

?
 `m.__self__` - это экземпляр объекта с методом `m()`
 `m.__func__` - объект-функция, соответствующая методу


В С++ есть возможность создать несколько конструкторов для разных шаблонов. В Python если переопределять одно и то же имя `__init__` даже с разными параметрами, всё равно ==последнее== определение будет "рабочим".

`__del__()` - деструктор - используется редко, т.к. есть "сборщик мусора".



Для профилирования кода (сколько работали отдельные функции, кто кого вызвал и т.д.) - `cProfile` на `C` и `profile` на `Python` более гибкий, но с доп. накладными расходами.